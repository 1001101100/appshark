/*
* Copyright 2022 Beijing Zitiao Network Technology Co., Ltd.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/


package net.bytedance.security.app.result

import kotlinx.serialization.Serializable
import net.bytedance.security.app.result.model.AnySerializer
import net.bytedance.security.app.result.model.SecurityVulnerabilityItem
import net.bytedance.security.app.rules.IRule
import net.bytedance.security.app.util.Json
import org.apache.commons.codec.digest.DigestUtils

interface IVulnerability {
    fun toDetail(): Map<String, @Serializable(with = AnySerializer::class) Any>
    val target: List<String>
    val position: String
}


@Serializable
class VulnerabilityItem(val rule: IRule, val url: String, val data: IVulnerability) {
    override fun hashCode(): Int {
        return rule.hashCode() + url.hashCode() + data.hashCode()
    }

    override fun equals(other: Any?): Boolean {
        if (other is VulnerabilityItem) {
            return other.rule == rule && other.url == url && other.data == data
        }
        return false
    }

    override fun toString(): String {
        return "vulnerabilityItem{name:${rule.name},url:$url,data:$data}"
    }

    fun isCompliance(): Boolean {
        return rule.desc.category == "ComplianceInfo"
    }

    fun toSecurityVulnerabilityItem(): SecurityVulnerabilityItem {
        val s = SecurityVulnerabilityItem()
        s.possibility = rule.desc.possibility
        val detail: MutableMap<String, @Serializable(with = AnySerializer::class) Any> = HashMap()
        detail.putAll(data.toDetail())
        s.details = detail
        var data = Json.encodeToString(s)
        data += rule.name
        val hash = DigestUtils.sha1Hex(data)
        if (url.isNotEmpty()) {
            detail["url"] = url
        }
        s.hash = hash
        s.details = detail
        return s
    }
}